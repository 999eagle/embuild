# Cargo <-> PlatformIO integration script (autogenerated by cargo-pio)
# Calling 'pio run' will also build the Rust library crate by invoking Cargo

import os

Import("env", "projenv")

class Cargo:
    def attach(self):
        # When calling into Cargo, attach to projenv so that the (potential) SYS crates
        # built by Cargo & Bindgen can also see the include directories of libraries downloaded with PlatformIO's Library Manager
        # These directories are currently only passed by PlatformIO to source code __inside__ the PlatformIO project,
        # hence the need to attach to the "cargo.c" "source" file
        projenv.AddPreAction(os.path.join("$BUILD_DIR", "src/cargo.o"), self.__run_cargo)

        # Linking needs to be done on the root environment
        env.AddPreAction(os.path.join("$BUILD_DIR", env.subst("$PROGNAME$PROGSUFFIX")), self.__link_cargo)

    def __init__(self):
        self.rust_lib = env.GetProjectOption("rust_lib")
        self.rust_target = env.GetProjectOption("rust_target")

        self.rust_bindgen_enabled = env.GetProjectOption("rust_bindgen_enabled", default = "false").lower() == "true"
        self.rust_bindgen_extra_clang_args = env.GetProjectOption("rust_bindgen_extra_clang_args", default = "")

        self.cargo_options = env.GetProjectOption("cargo_options", default = "")
        self.cargo_profile = env.GetProjectOption(
            "cargo_profile",
            default = "release" if env.GetProjectOption("build_type") == "release" else "debug")
        self.cargo_target_dir = env.GetProjectOption(
            "cargo_target_dir",
            default = os.path.join("$PROJECT_BUILD_DIR", "cargo")
                if env.GetProjectOption("cargo_pio_common_build_dir", default = False)
                else os.path.join("$PROJECT_DIR", "target"))

    def __run_cargo(self, source, target, env):
        board_mcu = env.get("BOARD_MCU")
        if not board_mcu and "BOARD" in env:
            board_mcu = env.BoardConfig().get("build.mcu")

        env["ENV"]["CARGO_PIO_BUILD_ACTIVE"] = "1"
        env["ENV"]["CARGO_PIO_BUILD_INC_FLAGS"] = env.subst("$_CPPINCFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LINK_FLAGS"] = env.subst("$_LIBFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LINKER"] = env.subst("$LINK")
        env["ENV"]["CARGO_PIO_BUILD_LIBS"] = env.subst("$LIBS")
        env["ENV"]["CARGO_PIO_BUILD_MCU"] = board_mcu

        if self.rust_bindgen_enabled:
            env["ENV"]["CARGO_PIO_BUILD_BINDGEN_RUN"] = "1"
            env["ENV"]["CARGO_PIO_BUILD_BINDGEN_EXTRA_CLANG_ARGS"] = self.rust_bindgen_extra_clang_args

        if env.Execute(f"cargo build {'--release' if self.cargo_profile == 'release' else ''} --lib --target {self.rust_target} {self.cargo_options}"):
            Exit(1)

    def __link_cargo(self, source, target, env):
        env.Prepend(LIBPATH = [os.path.join(self.cargo_target_dir, self.rust_target, self.cargo_profile)])
        env.Prepend(LIBS = [self.rust_lib])
        # A hack to workaround this issue with Rust's compiler intrinsics: https://github.com/rust-lang/compiler-builtins/issues/353
        env.Prepend(LINKFLAGS = "-Wl,--allow-multiple-definition")

Cargo().attach()
