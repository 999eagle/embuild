# Cargo <-> PlatformIO integration script (autogenerated by cargo-pio)
# Calling 'pio run' will also build the Rust library crate by invoking Cargo

import os

Import("env")

def run_cargo(source, target, env):
    rust_lib = env.GetProjectOption("rust_lib")
    rust_target = env.GetProjectOption("rust_target")

    cargo_options = env.GetProjectOption("cargo_options", default = "")

    cargo_profile = env.GetProjectOption(
        "cargo_profile",
        default = "release" if env.GetProjectOption("build_type") == "release" else "debug")

    cargo_target_dir = env.GetProjectOption(
        "cargo_target_dir",
        default = os.path.join("$PROJECT_BUILD_DIR", "cargo")
            if env.GetProjectOption("cargo_pio_common_build_dir", default = False)
            else os.path.join("$PROJECT_DIR", "target"))

    env["ENV"]["BINDGEN_INC_FLAGS"] = env.subst("$_CPPINCFLAGS")

    if env.Execute(f"cargo build {'--release' if cargo_profile == 'release' else ''} --lib --target {rust_target} {cargo_options}"):
        Exit(1)

    env.Prepend(LIBPATH = [os.path.join(cargo_target_dir, rust_target, cargo_profile)])
    env.Prepend(LIBS = [rust_lib])
    # A hack to workaround this issue with Rust's compiler intrinsics: https://github.com/rust-lang/compiler-builtins/issues/353
    env.Prepend(LINKFLAGS = "-Wl,--allow-multiple-definition")

env.AddPreAction(os.path.join("$BUILD_DIR", env.subst("$PROGNAME$PROGSUFFIX")), run_cargo)
